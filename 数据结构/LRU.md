>   LRU的算法思路是真的简单，概括下： 使用定长链表来保存所有缓存的值，并且最老的值放在链表最后面 当访问的值在链表中时： 将找到链表中值将其删除，并重新在链表头添加该值（保证链表中 数值的顺序是从新到旧） 当访问的值不在链表中时： 当链表已满：删除链表最后一个值，将要添加的值放在链表头 当链表未满：直接在链表头添加

>   比如引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。

-   用数组来实现 LRU 缓存淘汰策略。如何利用数组实现 LRU 缓存淘汰策略呢？

-   Q: **如何判断一个字符串是否是回文字符串**的问题，我想你应该听过，我们今天的题目就是基于这个问题的改造版本。如果字符串是通过*单链表*来存储的，那该*如何来判断是一个回文串*呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？

